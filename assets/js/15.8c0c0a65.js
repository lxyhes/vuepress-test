(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{540:function(a,v,_){"use strict";_.r(v);var s=_(5),h=Object(s.a)({},(function(){var a=this,v=a.$createElement,_=a._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h2",{attrs:{id:"_02、面试突击第一季、第二季以及第三季各自的侧重点是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_02、面试突击第一季、第二季以及第三季各自的侧重点是什么"}},[a._v("#")]),a._v(" 02、面试突击第一季、第二季以及第三季各自的侧重点是什么？")]),a._v(" "),_("p",[a._v("面试突击第一季：2018年的4月份，在全网免费公开的")]),a._v(" "),_("p",[a._v("面试突击第二季：2019年的8月份，在我的几个好朋友的公众号，狸猫技术窝，我在上面发售的一季课程，《互联网Java工程师面试训练营（分布式篇）》")]),a._v(" "),_("p",[a._v("面试突击第三季：2019年的12月初，我同样是在狸猫技术窝（公众号）上发售的")]),a._v(" "),_("p",[a._v("redis连环炮、mq连环炮、dubbo连环炮、分布式连环炮、elasticsearch连环炮")]),a._v(" "),_("p",[a._v("Java并发连环炮、mysql连环炮、网络连环炮、JDK集合连环炮、jvm连环炮、spring源码连环炮、tomcat连环炮、linux连环炮、系统设计连环炮、生产实践连环炮")]),a._v(" "),_("p",[a._v("面试突击第一季：面试官基本上是必考，而且会问很多比较实践性的一些问题")]),a._v(" "),_("p",[a._v("面试突击第二季：针对分布式架构这个专题，做了一个专题性的讲解，偏重于一些生产上的一些实践问题，展开性的、带一点点小深度、带一些生产实践的问题，基本上都是很多同学出去面试，回来问我")]),a._v(" "),_("p",[a._v("你们有几台服务器，都是什么配置的，每个服务部署几台机器，多少访问量，为什么要如此部署，类似这样的一些问题还是比较多的")]),a._v(" "),_("p",[a._v("面试突击第三季：对于每一个小专题，我们都会挑选几个最最高频的问题出来，给大家来讲解一下，尤其是并发、mysql优化、jvm优化，一些常规性的问题")]),a._v(" "),_("p",[a._v("分布式专题、微服务专题、海量数据专题、高性能专题、高并发专栏、高可用专题")]),a._v(" "),_("p",[a._v("面试突击系列，面试突击第四季，第五季，第六季，第七季，都会从每个专题抽取一些最新、最热门、最流行、现在面试最常问、最基础、大家最需要掌握的一些高频的问题和知识点，组成一季")]),a._v(" "),_("p",[a._v("间歇性的，偶尔出一个其他讲某个技术的小视频课程")]),a._v(" "),_("h2",{attrs:{id:"_03、来看几个并发、jvm和mysql的面试连环炮"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_03、来看几个并发、jvm和mysql的面试连环炮"}},[a._v("#")]),a._v(" 03、来看几个并发、JVM和MySQL的面试连环炮")]),a._v(" "),_("h2",{attrs:{id:"_04、学习完三季面试突击课程之后-你能拿下什么样的offer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_04、学习完三季面试突击课程之后-你能拿下什么样的offer"}},[a._v("#")]),a._v(" 04、学习完三季面试突击课程之后，你能拿下什么样的Offer？")]),a._v(" "),_("p",[_("strong",[a._v("从技术角度而言")]),a._v("：技术广度（面试突击一二三季）、技术深度（阅读源码、项目深度、开源社区）、项目经验（2C、2B、政企、金融、电信、CRUD）、架构设计（负责过的架构有多大，你能设计多大多复杂的架构）、基础知识（数据结构和算法、计算机组成原理、操作系统、网路协议）")]),a._v(" "),_("p",[_("strong",[a._v("从综合角度而言")]),a._v("：管理能力，学历，履历，软素质（表达能力、沟通能力、团队协作、价值观、性格），薪资要求")]),a._v(" "),_("p",[a._v("面试突击三季都学完 + 自己在面试过程中如果发现有一些问题是自己不会，要额外看一些书籍、或者别的课程、或者别的资料做一些补充")]),a._v(" "),_("p",[a._v("学历是211的本科、软素质、履历（之前就待过较为知名的公司），进BAT都可以")]),a._v(" "),_("p",[a._v("学历不是太出彩，软素质也较为一般，履历都是在一些小公司，起码就是说帮你面试中小型公司拿下offer，绝对是有很大的帮助的")]),a._v(" "),_("p",[a._v("学历不错，211、985之类的，软素质一般，履历之前反而是在国企、小公司，技术还可以，可能可以进一个独角兽企业")]),a._v(" "),_("p",[a._v("一线城市，20k+，20多k都是可以的")]),a._v(" "),_("p",[a._v("二线城市，十多k是可以的")]),a._v(" "),_("h2",{attrs:{id:"_05、除了学习面试突击课程之外-为了面试你还应该做哪些准备呢-》"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_05、除了学习面试突击课程之外-为了面试你还应该做哪些准备呢-》"}},[a._v("#")]),a._v(" 05、除了学习面试突击课程之外，为了面试你还应该做哪些准备呢？》")]),a._v(" "),_("p",[a._v("面试，比较多的一些新的热门和行情，无法涉及到")]),a._v(" "),_("p",[a._v("数据结构和算法，知识付费的平台，文字专栏、视频课程，踏踏实实的找两个专栏或者课程，都学好了，出去面试")]),a._v(" "),_("p",[a._v("在业务这块，DDD，领域驱动进行业务模型的设计，BAT大厂，美团之类的大厂，都在用DDD做复杂业务的设计，比较难，找到好的资料")]),a._v(" "),_("p",[a._v("目前得益于很多的一些在线教育机构，会把spring源码作为核心去讲解，外面很多公司都会拷问你的spring源码有没有读过，把这个spring源码自己找一些书籍，去看一下，做一点积累")]),a._v(" "),_("p",[a._v("设计秒杀系统，大路货，网上的文章和资料太多了")]),a._v(" "),_("p",[a._v("紧跟行业趋势和热点走向，平时多看一些书，多做一些积累，狸猫技术窝，大白话的视频课程，文字专栏，几十篇干货文章，几千个字，大白话一些，专栏设计出来一些别的地方没有的一些实战性的内容")]),a._v(" "),_("h2",{attrs:{id:"_06、为什么在java面试中一定会深入考察hashmap"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_06、为什么在java面试中一定会深入考察hashmap"}},[a._v("#")]),a._v(" 06、为什么在Java面试中一定会深入考察HashMap？")]),a._v(" "),_("p",[a._v("HashMap的深入考察，必然是面试中的一个核心的点")]),a._v(" "),_("p",[a._v("都是写Java代码，基于Java都是来构建各种各样的系统的，软件的，基于Java写出来一大堆的代码，可能会访问很多其他的东西，数据库，缓存，消息中间件，核心还是来写Java代码实现一些逻辑的运转")]),a._v(" "),_("p",[a._v("接收到一个请求，可能会创建一些数据结构，来存放一些数据，做一些循环、跳转、判断、加加减减，数据处理，逻辑，通过一大堆的逻辑就可以完成一些系统功能，或者是软件的功能")]),a._v(" "),_("p",[a._v("HashMap，数据结构，进行一定的逻辑的处理")]),a._v(" "),_("p",[a._v("一句话总结：你是Java工程师，你写代码的时候必然会用到一些数据结构，其中尤为经典的就是HashMap，别人必然会考察你")]),a._v(" "),_("h2",{attrs:{id:"_07、你知道hashmap底层的数据结构是什么吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_07、你知道hashmap底层的数据结构是什么吗"}},[a._v("#")]),a._v(" 07、你知道HashMap底层的数据结构是什么吗？")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v("HashMap<String, String> map = new HashMap<String, String>();\n\nmap.put(“张三”, “测试数据”);\n\nmap.put(“李四”, “测试数据”);\n{\n\n    “张三”: “测试数据”,\n\n    “李四”: “测试数据”\n\n}\n")])])]),_("p",[a._v("底层最核心的数据结构并不是你想的这样的")]),a._v(" "),_("p",[_("strong",[a._v("核心的数据结构是数组")])]),a._v(" "),_("p",[a._v("对张三计算出来一个hash值，根据这个hash值对数组进行取模，就会定位到数组里的一个元素中去")]),a._v(" "),_("p",[a._v("[<>, <>, <>, <>,<张三, 测试数据>, <>,<>,<李四, 测试数据>,<>, <>, <>, <>,<>, <>, <>, <>]")]),a._v(" "),_("p",[a._v("假设可以放16个元素，取模，算出index的位置")]),a._v(" "),_("p",[a._v("array[4] = <张三, 测试数据>")]),a._v(" "),_("p",[a._v("map.get(“张三”) -> hash值 -> 对数组长度进行取模 -> return array[4]")]),a._v(" "),_("h2",{attrs:{id:"_08、jdk-1-8中对hash算法和寻址算法是如何优化的-有点蒙"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_08、jdk-1-8中对hash算法和寻址算法是如何优化的-有点蒙"}},[a._v("#")]),a._v(" 08、JDK 1.8中对hash算法和寻址算法是如何优化的？（有点蒙）")]),a._v(" "),_("p",[a._v("map.put(“张三”, “测试数据”)")]),a._v(" "),_("p",[a._v("对“张三”这个key计算他的hash值，是有一定的优化的")]),a._v(" "),_("h3",{attrs:{id:"hash算法优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hash算法优化"}},[a._v("#")]),a._v(" hash算法优化")]),a._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v("\n\n// JDK 1.8以后的HashMap里面的一段源码\n  static final int hash(Object key) {\n     int h;\n\n\t return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n\n}\n")])])]),_("p",[a._v("比如说：有一个key的hash值")]),a._v(" "),_("p",[a._v("1111 1111 1111 1111 1111 1010 0111 1100")]),a._v(" "),_("p",[a._v("右移16位")]),a._v(" "),_("p",[a._v("0000 0000 0000 0000 1111 1111 1111 1111")]),a._v(" "),_("p",[a._v("异或运算之后")]),a._v(" "),_("p",[a._v("1111 1111 1111 1111 0000 0101 1000 0011 -> int值，32位")]),a._v(" "),_("p",[a._v("hash值一样 -> 他们其实都会在数组里放在一个位置，进行复杂的hash冲突的处理")]),a._v(" "),_("p",[a._v("[16个元素] -> hash值对数组长度取模，定位到数组的一个位置，塞进去就ok了")]),a._v(" "),_("p",[a._v("高低16位都参与运算")]),a._v(" "),_("h3",{attrs:{id:"寻址算法优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#寻址算法优化"}},[a._v("#")]),a._v(" 寻址算法优化")]),a._v(" "),_("p",[a._v("n表示的是数组的长度")]),a._v(" "),_("p",[a._v("(n - 1) & hash -> 数组里的一个位置")]),a._v(" "),_("p",[a._v("1111 1111 1111 1111 1111 1010 0111 1100（没有经过优化的hash值）")]),a._v(" "),_("p",[a._v("0000 0000 0000 0000 0000 0000 0000 1111")]),a._v(" "),_("p",[a._v("取模运算，他是性能比较差一些，为了优化这个数组寻址的过程")]),a._v(" "),_("p",[a._v("hash & (n - 1) -> 效果是跟hash对n取模，效果是一样的，但是与运算的性能要比hash对n取模要高很多，数学问题，数组的长度会一直是2的n次方，只要他保持数组长度是2的n次方")]),a._v(" "),_("p",[a._v("hash对n取模的效果 -> hash & (n - 1)，效果是一样的，后者的性能更高")]),a._v(" "),_("p",[a._v("1111 1111 1111 1111 1111 1010 0111 1100（没有经过优化的hash值）")]),a._v(" "),_("p",[a._v("0000 0000 0000 0000 0000 0000 0000 1111")]),a._v(" "),_("p",[a._v("相当于，你直接这么搞，高16位之间的与运算，是可以忽略的，核心点在于低16位的与运算，hash值的高16位没有参与到与运算里来啊")]),a._v(" "),_("p",[a._v("假设有两个hash值")]),a._v(" "),_("p",[a._v("1111 1111 1111 1111 1111 1010 0111 1100 -> 1111 1111 1111 1111 0000 0101 1000 0011")]),a._v(" "),_("p",[a._v("1111 1111 1111 1110 1111 1010 0111 1100 -> 1111 1111 1111 1110 0000 0101 1000 0010")]),a._v(" "),_("p",[a._v("1111 1111 1111 1111 0000 0101 1000 0011（经过优化和二进制位运算的新的hash值）")]),a._v(" "),_("p",[a._v("0000 0000 0000 0000 0000 0000 0000 1111")]),a._v(" "),_("p",[_("strong",[a._v("配合起来讲")])]),a._v(" "),_("p",[a._v("hash算法的优化：")]),a._v(" "),_("p",[a._v("对每个hash值，在他的低16位中，让高低16位进行了异或，让他的低16位同时保持了高低16位的特征，尽量避免一些hash值后续出现冲突，大家可能会进入数组的同一个位置")]),a._v(" "),_("p",[a._v("寻址算法的优化：")]),a._v(" "),_("p",[a._v("用与运算替代取模，提升性能")]),a._v(" "),_("h2",{attrs:{id:"_09、你知道hashmap是如何解决hash碰撞问题的吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_09、你知道hashmap是如何解决hash碰撞问题的吗"}},[a._v("#")]),a._v(" 09、你知道HashMap是如何解决hash碰撞问题的吗？")])])}),[],!1,null,null,null);v.default=h.exports}}]);